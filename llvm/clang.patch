Index: tools/clang/lib/Driver/Tools.cpp
===================================================================
--- tools/clang/lib/Driver/Tools.cpp	(revision 144800)
+++ tools/clang/lib/Driver/Tools.cpp	(working copy)
@@ -1112,6 +1112,10 @@
   // FIXME: Implement custom jobs for internal actions.
   CmdArgs.push_back("-cc1");
 
+  if (Args.hasArg(options::OPT_faddress_sanitizer)) {
+    CmdArgs.push_back("-DADDRESS_SANITIZER=1");
+  }
+
   // Add the "effective" target triple.
   CmdArgs.push_back("-triple");
   std::string TripleStr = getToolChain().ComputeEffectiveClangTriple(Args);
@@ -2464,6 +2468,39 @@
     }
   }
 
+  // AddressSanitizer Support.
+  if (isa<LinkJobAction>(JA)) {
+    if (Args.hasArg(options::OPT_faddress_sanitizer) && !Args.hasArg(options::OPT_shared)) {
+      const char *libasan_from_env = getenv("ASAN_LIB");  // temporary
+      std::string libasan;
+      if (libasan_from_env) {
+        libasan = libasan_from_env;
+      } else {
+        libasan = getToolChain().getDriver().Dir + "/../lib/libasan";
+        switch(getToolChain().getArch()) {
+        case llvm::Triple::x86:
+          libasan += "32.a";
+          break;
+        case llvm::Triple::x86_64:
+          libasan += "64.a";
+          break;
+        case llvm::Triple::arm:
+          libasan += "_arm.a";
+          break;
+        default:
+          libasan += "_arch_unsupported.a";
+        }
+      }
+      CmdArgs.push_back(Args.MakeArgString(libasan));
+      CmdArgs.push_back("-lpthread");
+      CmdArgs.push_back("-ldl");
+      CmdArgs.push_back("-export-dynamic");
+ 
+      getToolChain().AddCXXStdlibLibArgs(Args, CmdArgs);
+    }
+  }
+
+
   const std::string customGCCName = D.getCCCGenericGCCName();
   const char *GCCName;
   if (!customGCCName.empty())
@@ -3545,6 +3582,76 @@
 
   Args.AddAllArgs(CmdArgs, options::OPT_L);
 
+  // AddressSanitizer Support.
+  std::vector<std::string> asan_int_fns;
+  std::string pow_of_2[5] = {"1", "2", "4", "8", "16"};
+  for (int i = 0; i < 5; i++) {
+    asan_int_fns.push_back(std::string("___asan_report_load") + pow_of_2[i]);
+    asan_int_fns.push_back(std::string("___asan_report_store") + pow_of_2[i]);
+  }
+  asan_int_fns.push_back("___asan_register_global");
+  asan_int_fns.push_back("___asan_register_globals");
+  if (Args.hasArg(options::OPT_faddress_sanitizer) &&
+      !Args.hasArg(options::OPT_dynamiclib) && !Args.hasArg(options::OPT_bundle)) {
+    const char *libasan_from_env = getenv("ASAN_LIB");  // temporary
+    std::string libasan;
+    if (libasan_from_env) {
+      libasan = libasan_from_env;
+    } else {
+      libasan = getToolChain().getDriver().Dir + "/../lib/libasan";
+      switch(getToolChain().getArch()) {
+      case llvm::Triple::x86:
+        libasan += "32.a";
+        break;
+      case llvm::Triple::x86_64:
+        libasan += "64.a";
+        break;
+      case llvm::Triple::arm:
+        libasan += "_arm.a";
+        break;
+      default:
+        libasan += "_arch_unsupported.a";
+      }
+    }
+    CmdArgs.push_back(Args.MakeArgString(libasan));
+    CmdArgs.push_back("-lpthread");
+    CmdArgs.push_back("-ldl");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_malloc_default_purgeable_zone");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_malloc_zone_memalign");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_dispatch_async_f");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_dispatch_sync_f");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_dispatch_group_async_f");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_dispatch_barrier_async_f");
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("_dispatch_after_f");
+    // TODO(glider): do we need to always depend on Foundation?
+    CmdArgs.push_back("-framework");
+    CmdArgs.push_back("Foundation");
+    for (std::vector<std::string>::const_iterator it = asan_int_fns.begin();
+         it != asan_int_fns.end();
+         ++it) {
+      CmdArgs.push_back("-u");
+      CmdArgs.push_back(Args.MakeArgString(it->c_str()));
+    }
+    getToolChain().AddCXXStdlibLibArgs(Args, CmdArgs);
+  }
+  if (Args.hasArg(options::OPT_faddress_sanitizer) &&
+      (Args.hasArg(options::OPT_dynamiclib) || (Args.hasArg(options::OPT_bundle)))) {
+    CmdArgs.push_back("-U");
+    CmdArgs.push_back("___asan_init");
+    for (std::vector<std::string>::iterator it = asan_int_fns.begin();
+         it != asan_int_fns.end();
+         ++it) {
+      CmdArgs.push_back("-U");
+      CmdArgs.push_back(Args.MakeArgString(it->c_str()));
+    }
+  }
   if (Args.hasArg(options::OPT_fopenmp))
     // This is more complicated in gcc...
     CmdArgs.push_back("-lgomp");
@@ -3583,6 +3690,8 @@
     getDarwinToolChain().AddLinkRuntimeLibArgs(Args, CmdArgs);
   }
 
+
+
   if (!Args.hasArg(options::OPT_A) &&
       !Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nostartfiles)) {
@@ -4425,6 +4534,36 @@
 
   AddLinkerInputs(ToolChain, Inputs, Args, CmdArgs);
 
+  // AddressSanitizer Support.
+  if (Args.hasArg(options::OPT_faddress_sanitizer) && !Args.hasArg(options::OPT_shared)) {
+    const char *libasan_from_env = getenv("ASAN_LIB");  // temporary
+    std::string libasan;
+    if (libasan_from_env) {
+      libasan = libasan_from_env;
+    } else {
+      libasan = getToolChain().getDriver().Dir + "/../lib/libasan";
+      switch(getToolChain().getArch()) {
+      case llvm::Triple::x86:
+        libasan += "32.a";
+        break;
+      case llvm::Triple::x86_64:
+        libasan += "64.a";
+        break;
+      case llvm::Triple::arm:
+        libasan += "_arm.a";
+        break;
+      default:
+        libasan += "_arch_unsupported.a";
+      }
+    }
+    CmdArgs.push_back(Args.MakeArgString(libasan));
+    CmdArgs.push_back("-lpthread");
+    CmdArgs.push_back("-ldl");
+    CmdArgs.push_back("-export-dynamic");
+
+    ToolChain.AddCXXStdlibLibArgs(Args, CmdArgs);
+  }
+
   if (D.CCCIsCXX && !Args.hasArg(options::OPT_nostdlib)) {
     bool OnlyLibstdcxxStatic = Args.hasArg(options::OPT_static_libstdcxx) &&
       !Args.hasArg(options::OPT_static);
